# TIL 230309(목)

1. 비동기 처리
    - promise
        - promise chaining이란?    
        promise의 then 핸들러의 체인(사슬)에 의해 result가 전달되는 것.
            ```javascript
            new Promise(function(resolve, reject) {
                setTimeout(() => resolve(1), 1000);
            }).then(function(result) {
                alert(result);
                return result * 2;
            }).then(function(result) {
                alert(result);
                return result * 2;
            }).then(function(result) {
                alert(result); 
                return result * 2;
            });
            ```
    - async/await
2. JavaScript ES6 문법
    - var, let, const
        - **스코프(scope)**:    
        변수에 접근할 수 있는 범위를 의미함
        - **컨텍스트(context)**:    
        함수가 속해있는 객체(this 키워드 값)
        - 함수 스코프 vs 블록 스코프
            - 함수 스코프:    
            함수에서 선언한 변수는 해당 함수 안에서만 접근 가능(새로운 함수가 생성될 때마다 새로운 스코프 발생)
            - 블록 스코프:    
            블록 내부에서 선언된 변수는 해당 블록에서만 접근 가능(블록이 생성될 때마다 새로운 스코프가 발생)
            - javascript는 기본적으로 함수 스코프를 따름
            - var는 **함수 스코프**이고, let과 const는 **블록 스코프**임
            - var는 중복선언이 가능하며, let과 const는 불가능함
            - var와 let은 값을 변경할 수 있으나 const는 불가능함
            - var는 버그 발생, 메모리 누수 등의 위험이 있어 let과 const 사용을 추천함
3. 코드 분석
    - 코드 분석법
        ```
        코드 분석법 여기에 작성하기(코드분석 레포지토리 read.me에 넣고 그 링크를 여기 넣기)
        ```
    - 묵찌빠 레퍼런스 코드 분석
        ```
        코드분석한 내용 여기에 작성하기(혹은 코드분석 레포지토리 링크를 여기 넣기)
        ```
---
## 이슈
- promise
    ```javascript
    // 1번 코드 (promise chaining)
    new Promise((resolve, reject) => {
        setTimeout(() => resolve("3초가 지났습니다."),3000);
    }).then(res=>{
        console.log(res);
        return new Promise((resolve, reject)=>{
            setTimeout(()=>resolve("2초가 지났습니다."),2000);
        })
    }).then(res=>{
        console.log(res);
        return new Promise((resolve, reject)=>{
            setTimeout(()=>resolve("1초가 지났습니다."),1000);
        })
    }).then(res => console.log(res));

    // 2번 코드 (1번 코드의 promise를 변수로 선언하여 구현함)
    const delay3 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("3초가 지났습니다."),3000);
    });
    const delay2 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("2초가 지났습니다."),2000);
    });
    const delay1 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("1초가 지났습니다."),1000);
    });

    delay3.then(res=>{
        console.log(res);
        return delay2;
    }).then(res=>{
        console.log(res);
        return delay1;
    }).then(res=>{
        console.log(res);
    })

    //3번 코드 (2번 코드의 변수를 function으로 변경하여 실행)
    const delay3 = () => new Promise((resolve, reject) => {
    setTimeout(() => resolve("3초가 지났습니다."),3000);
    });
    const delay2 = () => new Promise((resolve, reject) => {
        setTimeout(() => resolve("2초가 지났습니다."),2000);
    });
    const delay1 = () => new Promise((resolve, reject) => {
        setTimeout(() => resolve("1초가 지났습니다."),1000);
    });

    delay3().then((res)=>{
        console.log(res);
        return delay2();
    }).then((res)=>{
        console.log(res);
        return delay1();
    }).then(res=>{
        console.log(res);
    })
    ```
    - 3초 딜레이 후 "3초가 지났습니다.", 2초 딜레이 후 "2초가 지났습니다.", 1초 딜레이 후 "1초가 지났습니다"를 출력하기 위해 만든 코드이다.    
    - 1번 코드와 3번 코드는 정상적으로 작동하지만, 2번 코드는 3초 딜레이 후 모든 메시지가 동시에 출력된다.
    - 이렇게 동작하는 이유는?
        - new Promise()는 promise의 생성자 함수이다. 3번 코드처럼 new Promise를 함수에 집어넣었다는 것은 포장을 했다고 볼 수 있는데, 이때문에 delay변수들이 만들어졌을 때가 아니라 함수가 호출된 시점부터 promise가 작동을 시작하도록 할 수 있다.
        - promise를 사용하는 시점에 생성자 함수를 작성한 1번 코드도 사용하는 시점에 함수를 불러오는 것과 같이 작동한다.
        - 하지만 2번 코드에서 delay변수들은 만들어지는 시점에 이미 생성자 함수가 동작했다고 볼 수 있는데, 밑의 예제로 확실히 확인할 수 있다.
        ```javascript
        // 1번 코드
        const delay3 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("3초가 지났습니다."),3000);
        });
        const delay2 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("2초가 지났습니다."),2000);
        });
        const delay5 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("5초가 지났습니다."),5000);
        });

        delay5.then(()=>{
            const delay1 = new Promise((resolve, reject) => {
                setTimeout(() => resolve("1초가 지났습니다."),1000);
            });

            delay3.then((res)=>{
                console.log(res);
                return delay2;
            }).then((res)=>{
                console.log(res);
                return delay1;
            }).then(res=>{
                console.log(res);
            })
        })

        // 2번 코드
        const delay3 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("3초가 지났습니다."),3000);
        });
        const delay2 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("2초가 지났습니다."),2000);
        });
        const delay1 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("1초가 지났습니다."),1000);
        });
        const delay5 = new Promise((resolve, reject) => {
            setTimeout(() => resolve("5초가 지났습니다."),5000);
        });

        delay5.then(()=>{

            delay3.then((res)=>{
                console.log(res);
                return delay2;
            }).then((res)=>{
                console.log(res);
                return delay1;
            }).then(res=>{
                console.log(res);
            })
        })
        ```
    - 1번 코드에서는 1초의 딜레이를 갖는 delay1변수가 delay5 안에서 선언되었고, 2번 코드에서는 다른 변수들과 함께 delay5 밖에서 선언되었다.
    - 1번 코드 실행 결과:    
    5초의 딜레이 후 "3초가 지났습니다."와 "2초가 지났습니다."가 함께 출력됨. 그 후 1초의 딜레이 후 "1초가 지났습니다." 출력됨
    - 2번 코드 실행 결과:    
    5초의 딜레이 후 모든 메시지가 동시에 출력됨
    - 변수가 선언되는 시점에 promise가 동작을 시작했기 때문에 delay1은 (변수가 생성되기 전 5초) + (promise 동작 1초)로 총 6초의 딜레이를 가지게 되었다.
    ### 결론
    - promise를 미리 선언해두고 원하는 시점에 동작시키고 싶으면 함수에 담아 포장해서 사용하자
---
## 출처  
- (promise, async/await) 인프런 강의 - 한입 크기로 잘라 먹는 리액트(React.js) : 기초부터 실전까지
- (비동기 처리) https://rough-helium-012.notion.site/JS_Asynchronous-068d23909212417eb7726bcab59cd897
- (promise chaining) https://ko.javascript.info/promise-chaining
- (JavaScript ES6 문법) https://mong-blog.tistory.com/entry/%EB%B8%94%EB%A1%9D-%EC%8A%A4%EC%BD%94%ED%94%84-%ED%95%A8%EC%88%98-%EC%8A%A4%EC%BD%94%ED%94%84%EC%9D%98-%EC%B0%A8%EC%9D%B4-javascript?category=967416
- (JavaScript ES6 문법) https://hanamon.kr/javascript-es6-%EB%AC%B8%EB%B2%95/
- (JavaScript ES6 문법) https://velog.io/@fromzoo/%ED%95%A8%EC%88%98%EC%8A%A4%EC%BD%94%ED%94%84-vs-%EB%B8%94%EB%A1%9D%EC%8A%A4%EC%BD%94%ED%94%84
- (JavaScript ES6 문법) https://www.freecodecamp.org/korean/news/var-let-constyi-caijeomeun/
- (JavaScript ES6 문법) https://github.com/mobiliverse-inc/intern-project/blob/main/development_note/var_let_const.md